---
icon: edit
date: 2023-07-07
category:
  - 算法
tag:
  - 动态规划
  - 背包问题
---
# 动态规划背包问题
##  0-1 背包
### 背景
 0-1 背包指在总金额N的范围中,放入指定物体(每样只有一个,可以不放),求最大总价值的问题

### 思路
选择使用动态规划。定义一个二维dp[i][j],其中,i表示在序号小于i的物品中任意选择,j表示背包大小,即dp[i][j]表示在前i个物品中选择重量不大于j的物品的最大价值。每一次更新时如果能装下,有2个选择(拿——dp[i-1][j-w[i]]+v[i],不拿——dp[i-1][j]),装不下就保留没有包括此物品物品的状态dp[i-1][j]。
状态转移方程中的dp[i][j]=dp[i-1][j-w[i]]+v[i]表示要拿这个物品,就用没有包括此物品时的最大值(这里的j-w[i]是为第i个物品预留位置)加上第i个物品的价值。如果不拿,就保留i-1的状态。

### 状态转移方程
$$ f_{i,j}=max(f_{i-1,j},f_{i-1,j-w_i}+v_i) $$
### 模板代码
```cpp
int main(){
    dp[1][1]=0;
    for(int i=1;i<=m;i++){
        for(int j=1;j<=n;j++){
            if(j<w[i])//装不下
                dp[i][j]=dp[i-1][j];
            else{
                dp[i][j]=max(dp[i-1][j-w[i]]+v[i],dp[i-1][j]);
            }
        }
    }
}
```

最后,dp[m][n]就是能装下的总价值的最大值,如果要求总方案,可以修改状态转移方程

### dp空间优化
#### 模板代码
```cpp
int main(){
    dp[1]=0;
    for(int i=1;i<=m;i++){
        for(int j=n;j>=w[i];j--){
                dp[j]=max(dp[j-w[i]]+v[i],dp[j]);
        }
    }
}
```
#### 原理
在上面的代码中,我们可以发现每一次的状态转移只和上一行有关,最后的结果也只与最后一行有关,因此,不必保存之前的状态。在每次更新时,如果从前向后遍历j,j-w[i]会被新值覆盖,所以这里从后向前遍历,如果j小于w[i]是装不下的,就可以不进行操作,数组里便是原来的值
## 完全背包
### 背景
对于 0-1 背包，只存在两个状态——拿或不拿，而完全背包用于解决物品个数由无限个，但需要将背包装满(完全)的问题
### 思路
与 0-1 背包相似，完全背包仍然定义了一个dp[i][j]，i和j的意义与 0-1 背包一致，但因为这里可以拿无限个，所以在状态转移方程中有所差异。不拿的情况依旧是从dp[i-1][j]更新，但拿的时候需要在少拿一个(而不是不拿这个)的基础上加上价值，也就是dp[i][j-w[i]]+v[i]
### 状态转移方程
$$ f_{i,j}=max(f_{i-1,j},f_{i,j-w_i}+v_i) $$
### 模板代码
```cpp
int main(){
    dp[1][1]=0;
    for(int i=1;i<=m;i++){
        for(int j=1;j<=n;j++){
            if(j<w[i])//装不下
                dp[i][j]=dp[i-1][j];
            else{
                dp[i][j]=max(dp[i][j-w[i]]+v[i],dp[i-1][j]);
            }
        }
    }
}
```
最后,dp[m][n]就是能装下的总价值的最大值,如果要求总方案,可以修改状态转移方程
### dp空间优化
#### 模板代码
```cpp
int main(){
    dp[1]=0;
    for(int i=1;i<=m;i++){
        for(int j=w[i];j<=n;j++){
                dp[j]=max(dp[j-w[i]]+v[i],dp[j]);
        }
    }
}
```
#### 原理
原理与[0-1 背包dp空间优化](https://blog.sciencekill.top/posts/Algorithm/Dynamic_Programming/Knapsack_Problem.html#dp空间优化)相似，但这里访问的是当行的j-w[i]，所以需要在更新完之后在进行访问，所以for循环是正序的