---
icon: edit
date: 2023-07-07
category:
  - 算法
tag:
  - 动态规划
  - 背包问题
---
# 0-1 背包
## 背景
0-1 背包指在总金额N的范围中,放入指定物体(每样只有一个,可以不放),求最大总价值的问题

## 思路
选择使用动态规划。定义一个二维dp[i][j],其中,i表示在序号小于i的物品中任意选择,j表示背包大小,即dp[i][j]表示在前i个物品中选择重量不大于j的物品的最大价值。每一次更新时如果能装下,有2个选择(拿——dp[i-1][j-w[i]]+v[i],不拿——dp[i-1][j]),装不下就保留没有包括此物品物品的状态dp[i-1][j]。
状态转移方程中的dp[i][j]=dp[i-1][j-w[i]]+v[i]表示要拿这个物品,就用没有包括此物品时的最大值(这里的j-w[i]是为第i个物品预留位置)加上第i个物品的价值。如果不拿,就保留i-1的状态。

PS:w是物品重量,v是物品价值
## 模板代码
```C++
int main(){
    for(int i=1;i<=m;i++){
        for(int j=1;j<=n;j++){
            if(j<w[i])//装不下
                dp[i][j]=dp[i-1][j];
            else{
                dp[i][j]=max(dp[i-1][j-w[i]]+v[i],dp[i-1][j]);
            }
        }
    }
}
```
PS:dp[1][1]=0;

最后,dp[m][n]就是能装下的总价值的最大值,如果要求总方案,可以修改状态转移方程

## dp空间优化
### 模板代码
```C++
int main(){
    dp[1]=0;
    for(int i=1;i<=m;i++){
        for(int j=n;j>=w[i];j--){
                dp[j]=max(dp[j-w[i]]+v[i],dp[j]);
        }
    }
}
```
### 原理
在上面的代码中,我们可以发现每一次的状态转移只和上一行有关,最后的结果也只与最后一行有关,因此,不必保存之前的状态。在每次更新时,如果从前向后遍历j,j-w[i]会被新值覆盖,所以这里从后向前遍历,如果j小于w[i]是装不下的,就可以不进行操作,数组里便是原来的值